<html>
  <head>
    <title>Cytoscape Test</title>
    <meta charset= utf-8 />
    <style>
	body {
		width: 100%;
		height: 100%;
		font: 14px helvetica neue, helvetica, arial, sans-serif;
		overflow: hidden;
	}

	#cy {
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
	}
	
	.node-settings{
		max-width: 200px;
		display: none;
	}
	
	.edge-settings{
		max-width: 200px;
		display:none;
	}

	.config {
	  position: absolute;
	  right: 0;
	  top: 0;
	  bottom: 0;
	  width: 20em;
	  background: rgba(0, 0, 0, 0.75);
	  box-sizing: border-box;
	  padding: 1em;
	  color: #fff;
	  transition-property: opacity;
	  transition-duration: 250ms;
	  transition-timing-function: ease-out;
	  overflow: auto;
	  z-index: 1;
	}

	.config > h2{
		margin-top: 3px;
	}

	.config-toggle {
	  position: absolute;
	  right: 5;
	  top: 5;
	  padding: 1em;
	  margin: 0.2em;
	  cursor: pointer;
	  color: #888;
	  z-index: 9999999;
	}

	.config-closed .config {
	  opacity: 0;
	  pointer-events: none;
	}

	.config-closed #cy {
	  right: 0;
	}
    </style>
	<!-- Main Scripts -->
    <script src="./jquery.min.js"></script>
    <script src="./cytoscape.min.js"></script>
	
	<!-- Bootstrap -->
	<link href="/~jacksoor/css/bootstrap.min.css" rel="stylesheet" type="text/css">
	
	<!-- Tooltips -->
	<script src="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.js"></script>
	<link href="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.css" rel="stylesheet" type="text/css" />
	<script src="./cytoscape-qtip.js"></script>
	
  	<script>
	document.addEventListener('DOMContentLoaded', function(){ // on dom ready

	var cy = cytoscape({
	  container: document.querySelector('#cy'),
	
	  boxSelectionEnabled: false,
	  autounselectify: true,
	  
	  style: cytoscape.stylesheet()
		.selector('node')
		  .css({
			'content': 'data(name)',
			'text-valign': 'center',
			'background-color': 'white',
			'color': 'black',
			'border-width': '2px',
			'border-style': 'solid',
			'border-color': 'black',
			'z-index' : '1'
		  })
		.selector('edge')
		  .css({
			'label': 'data(transitionSymbols)',
			'text-outline-width': '2px',
			'text-outline-color': 'white',
			'target-arrow-shape': 'triangle',
			'target-arrow-color': 'black',
			'line-color': 'black'
		  })
		.selector(':selected')
		  .css({
			'background-color': 'black',
			'line-color': 'black',
			'target-arrow-color': 'black',
			'source-arrow-color': 'black'
		  })
		.selector('.endState')
		  .css({
			'border-width': '5px',
			'border-style': 'double',
			'border-color': 'black',
		  })
		.selector('.ghostNode')
		  .css({
			'width': '0px',
			'height': '0px',
		  })
		.selector('.link')
		   .css({
		     'background-color': 'red'
		   })
		.selector('.linker')
		   .css({
			'width': '0px',
			'height': '0px',
			'text-valign': 'center',
			'z-index': '0'
			})
		.selector('.highlighted')
			.css({
			  'background-color': '#61bffc',
			  'line-color': '#61bffc',
			  'target-arrow-color': '#61bffc',
			  'transition-property': 'background-color, line-color, target-arrow-color',
			  'transition-duration': '0.5s'
			}),
	  //sample elements
	  /*elements: {
		nodes: [
			{ data: { id: 't1', name: 'z0', isStartState: true, isEndState: false, hasLoop: false } },
			{ data: { id: 't2', name: 'z1', isStartState: false, isEndState: false, hasLoop: false } },
			{ data: { id: 't3', name: 'z2', isStartState: false, isEndState: false, hasLoop: false } },
		],
		edges: [
			{ data: { id: 'te1', source: 't1', transitionSymbols: 'a', target: 't2' } },
			{ data: { id: 'te2', source: 't2', transitionSymbols: 'b', target: 't3' } },
		]
	  },*/
	  
	  layout: {
		name: 'grid',
		padding: 10
	  }
	});
	
	var stateCounter = 0;
	var edgeCounter = 0;
	var ghostCounter = 0;
	
	var linkSourceNode = null;
	var linkingMode = false;
	
	var holdTimer;
	var settingsActive = false;
	var editNode = null;
	var editEdge = null;
	
	//Begin linking mode, arrow pointing to mouse
	function startLinkingMode(event){
		linkSourceNode = event.cyTarget;
		linkSourceNode.addClass('link');
		cy.add([
			{ group: "nodes", data: { id: "linker", isGhost: true}, renderedPosition: event.cyRenderedPosition },
			{ group: "edges", data: { id: "newLink", source: linkSourceNode.id(), target: 'linker' } },
		]);
		cy.$('#linker').addClass('linker');
		linkingMode = true;
	}
	
	function endLinkingMode(){
		linkSourceNode.removeClass('link');
		linkSourceNode = null;
		cy.$('#linker').remove();
		cy.nodes().unlock();
		linkingMode = false;
	}
	
	function showNodeSettings(event){
		//Create tooltip on longpress and save api
		editNode = event.cyTarget;
		editNode.lock();
		//Get Settings
		var settingsForm = $('#nodeSettings').clone();
		settingsForm.find('#inputStateName').val(editNode.data('name'));
		settingsForm.find('#checkStartState').prop('checked', editNode.data('isStartState'));
		settingsForm.find('#checkEndState').prop('checked', editNode.data('isEndState'));
		settingsForm.find('#checkHasLoop').prop('checked', editNode.data('hasLoop'));
		
		qTipSettingsApi = editNode.qtip({
		  content: { text : settingsForm  },
		  position: {
			my: 'top center',
			at: 'top center',
		  },
		  show: {
			solo: true,
			event: 'false'
		  },
		  events: {
			hide: function(event, api) {
				editNode.unlock();
				this.qtip('api').destroy();
				settingsActive = false;
				}
			},
		  style: {
			classes: 'qtip-bootstrap',
			tip: {
			  width: 16,
			  height: 8
			}
		  }
		})
		.qtip('api');
		qTipSettingsApi.show();
		settingsActive = true;
	}

	function showEdgeSettings(event){
		editEdge = event.cyTarget;
		//Get Settings
		var settingsForm = $('#edgeSettings').clone();
		settingsForm.find('#inputTransitionSymbols').val(editEdge.data('transitionSymbols'));
		
		qTipSettingsApi = editEdge.qtip({
		  content: { text : settingsForm  },
		  position: {
			
			target: cy.$('#'+editEdge.id())
		  },
		  show: {
			solo: true,
			event: 'false'
		  },
		  events: {
			hide: function(event, api) {
				this.qtip('api').destroy();
				settingsActive = false;
				}
			},
		  style: {
			classes: 'qtip-bootstrap',
			tip: {
			  width: 16,
			  height: 8
			}
		  }
		})
		.qtip('api');
		qTipSettingsApi.show();
		settingsActive = true;
	}
	
	function setStateName(newName){
		editNode.data('name', newName);
	}
	
	function setStartState(node, boolParam){
		node.data('isStartState',boolParam);
		if(boolParam){
			//Copy position
			var anchorPosition = jQuery.extend({}, node.position());
			anchorPosition.x -= 75;
			cy.add([
				  { group: "nodes", data: { id: "gn"+ghostCounter , isGhost: true, isGhostStartNode: true, toStartNode: node }, grabbable: false, position: anchorPosition },
				  { group: "edges", data: { id: "ge"+ghostCounter, source: "gn"+ghostCounter, target: node.id(), isGhostStartLink: true  } },
				]);
			cy.$('#gn'+ghostCounter).addClass('ghostNode');
			//Add ghost node as Attribute
			editNode.data('startGhost', cy.$("#gn"+ghostCounter));
			ghostCounter++;
		}
		else{
			node.data('startGhost').remove();
		}
	}
	
	//Set isEndState to new boolParam
	function setEndState(boolParam){
		editNode.data('isEndState',boolParam);
		if(boolParam){
			editNode.addClass('endState');
		}
		else{
			editNode.removeClass('endState');
		}
	}
	
	function setLoop(node, boolParam){
		node.data('hasLoop', boolParam);
		//Create new self loop
		if(boolParam){
			cy.add([
				{ group: "edges", data: { id: "e"+edgeCounter, source: node.id(), target: node.id() } },
				]);
			edgeCounter++;
		}
		//Check if theres a self loop
		else if(node.edgesTo(node).length == 1){
			node.edgesTo(node).remove();
		}
	}

	function setTransitionSymbols(edge, newSymbols){
		edge.data('transitionSymbols', newSymbols);
	}
	
	//Prevent enter-submit on form
	$(document).on('submit', '#formNodeSettings', function() {
		qTipSettingsApi.hide();
		return false;
	});

	$(document).on('submit', '#formEdgeSettings', function() {
		qTipSettingsApi.hide();
		return false;
	});
	
	//Get settings changes for each created checkbox
	$(document).on('change', '#inputStateName', function(){
		setStateName($(this).val());
	});
	
	$(document).on('change', '#checkStartState', function(){
		setStartState(editNode, $(this).prop('checked'));
	});
	
	$(document).on('change', '#checkEndState', function(){
		setEndState($(this).prop('checked'));
	});
	
	$(document).on('change', '#checkHasLoop', function(){
		setLoop(editNode, $(this).prop('checked'));
	});

	$(document).on('change', '#inputTransitionSymbols', function(){
		setTransitionSymbols(editEdge, $(this).val());
	});
	
	//Tap and hold to show settings, cancel on mouseup or mousemove
	cy.on('tapstart', 'node', function(event){
		holdTimer = setTimeout(function() {
			showNodeSettings(event);
		}, 600);
	}).bind('mouseup mousemove', function(){
		clearTimeout(holdTimer);
	});
	
	//Select Nodes for link
	cy.on('tap', 'node', function(event){
		//We don't want to interfere with qtip settings
		if(settingsActive)
			return;
		//No node selected
		if(linkSourceNode == null){
			if(event.cyTarget.data('isGhost'))
				return;
			startLinkingMode(event);
		}
		//Unselect selected node
        else if(event.cyTarget == linkSourceNode){
				endLinkingMode();
		}
		//Link the selected node to the event node
		else{
			if(event.cyTarget.data('isGhost'))
				return;

			if(linkSourceNode.edgesTo('#'+event.cyTarget.id()).length == 0){
				cy.add([
					{ group: "edges", data: { id: "e"+edgeCounter, source: linkSourceNode.id(), transitionSymbols: '', target: event.cyTarget.id() } },
				]);
				edgeCounter++;
			}
			endLinkingMode();
		}
	});

	cy.on('tap', 'edge', function(event){
		showEdgeSettings(event);
	});
	
	//Event to move ghost start node with actual node
	cy.on('drag' , 'node', function(event){
		if(event.cyTarget.data('isStartState')){
			var anchorPosition = jQuery.extend({}, event.cyTarget.position());
			anchorPosition.x -= 75;
			event.cyTarget.data('startGhost').position(anchorPosition);
		}
	});
	
	cy.on('tapdrag', function(event){
		if(linkingMode){
			cy.$('#linker').renderedPosition(event.cyRenderedPosition);
		}
	});
	
	cy.on('cxttap', function(event){
		//Event is on canvas
		if(event.cyTarget === cy){
			//Add a new node
			cy.add([
			  { group: "nodes", data: { id: "z"+stateCounter , name: "z"+stateCounter, isStartState: false, isEndState: false, hasLoop: false }, renderedPosition: event.cyRenderedPosition },
			]);
			stateCounter++;
		}
		else if(event.cyTarget.isNode()){
			if(event.cyTarget.data('isGhostStartNode')){
				setStartState(event.cyTarget.data('toStartNode'), false);
				return;
			}
			cy.remove(event.cyTarget);
		}
		else if(event.cyTarget.isEdge()){
			//Adjust properties of looped node
			if(event.cyTarget.isLoop()){
				setLoop(event.cyTarget.source(), false);
			}
			//Removed ghost link for starting state
			else if(event.cyTarget.data('isGhostStartLink')){
				setStartState(event.cyTarget.target(), false);
				return;
			}
			cy.remove(event.cyTarget);
		}
	});

	$('#configToggle').on('click', function(){
		$('body').toggleClass('config-closed');
		cy.resize();
	});
	
	$('#btnTestWord').on('click', function(){
		acceptsWord($('#inputWord').val())
	});
	
	
	//console.log('Cytoscape initalized');
	
	var highlighCount;
	var highlightPath;
	var inputWord;

	function acceptsWord(word){
		cy.elements().removeClass('highlighted');
		var currentNodes = cy.elements('node[?isStartState]');
		var path = [];
		inputWord = word;
		path.push(currentNodes);
		for (var i = 0, len = word.length; i < len; i++) {
			if(currentNodes.empty()){
				alert('wort nicht akzeptiert!');
				return;
			}
			var nextNodes = cy.collection();
			var neighborEdges = currentNodes.edgesTo(currentNodes.neighborhood());
			neighborEdges.each(function(i, ele){
				if($.inArray(ele.data('transitionSymbols').split(","),word[i])){
					path.push(ele);
					nextNodes = nextNodes.add(ele.target());
				}
			});
			if(!nextNodes.empty()){
				path.push(nextNodes)
			}
			var currentNodes = nextNodes;
		};
		highlightCount = 0;
		highlightPath = path;
		highlightPathNext();
	}
	
	var highlightPathNext = function(){
		if(highlightCount < highlightPath.length){
			highlightPath[highlightCount].addClass('highlighted');
			highlightCount++;
			setTimeout(highlightPathNext, 750);
		}
		else{
			var accepted = false;
			highlightPath[highlightCount-1].each(function(i, ele){
				if(ele.data('isEndState')){
					accepted = true;
				}
			});
			if(accepted){
				alert(inputWord + ' wurde akzeptiert!');
			}
			else{
				alert(inputWord + ' wurde NICHT akzeptiert!');
			}
			
		}
	}

	}); // on dom ready
	</script>
  </head>
  <body>
  	<div id="cy"></div>

	<button type="button" class="btn btn-info btn-lg config-toggle" id="configToggle" aria-label="Left Align">
		<span class="glyphicon glyphicon-menu-hamburger" aria-hidden="true"></span>
	</button>

    <div id="config" class="config">
		<h2>Optionen</h2>
		<!--<label for="inputAlphabet">Eingabealphabet:</label>
		<input type="text" class="form-control" id="inputAlphabet" placeholder="Mit ">-->
		<label for="inputWord">Eingabewort:</label>
		<input type="text" class="form-control" id="inputWord" placeholder="bsp. abab">
		<button class="btn btn-default" id="btnTestWord">Testen</button>
    </div>

	<div class="node-settings" id="nodeSettings">
		<form id='formNodeSettings'>
		<div class="form-group">
			<label for="inputStateName">Zustandsname</label>
			<input type="text" class="form-control" id="inputStateName" placeholder="Name">
		</div>
		<div class="checkbox">
			<label>
				<input type="checkbox" id="checkStartState"> Ist Startzustand
			</label>
		</div>
		<div class="checkbox">
			<label>
				<input type="checkbox" id="checkEndState"> Ist Endzustand
			</label>
			</div>
		<div class="checkbox">
			<label>
			  <input type="checkbox" id="checkHasLoop"> Loop
			</label>
		</div>
		</form>
	</div>

	<div class="edge-settings" id="edgeSettings">
		<form id='formEdgeSettings'>
		<div class="form-group">
			<label for="inputTransitionSymbols">Übergangszeichen</label>
			<input type="text" class="form-control" id="inputTransitionSymbols" placeholder="bsp. a,b">
		</div>
		</form>
	</div>
  </body>
</html>
